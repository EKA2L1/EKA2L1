{
	"Panic": {
		"CServer2": {
			"0": "Message opcode number is invalid. Message opcode not in range of [-1, +nan)",
			"1": "Session haven't been connected to server to process opcode",
			"2": "Session has already been connected to server",
			"3": "Client doesn't have required capabilities to use this server"
		},
		
		"CSession2": {
			"2": "Resource count saved in ResourceCountMarkStart is different than resource count returned in ::ResourceCount",
			"1": "Resource count is not overriden but called"
		},
		
		"USER-EXEC": {
			"3": "Exception is raised but no exception handler in current thread or exception is hardware/processor thrown (divide by zero)"
		},
	
		"USER": {
			"0": "Invariant is called",
			"3": "TDateTime is constructed with invalid date or time field",
			"7": "Pointer of a 16-bit descriptor is invalid",
			"8": "Length passed to 16-bit variant descriptor is invalid",
			"9": "Accessing element of 16-bit descriptor out of range",
			"10": "Accessing element of 16-bit descriptor out of range",
			"11": "Destination 16-bit descriptor can't hold the data that is copied/moved from another descriptor (exceed maximum length)",
			"12": "16-bit format string has invalid syntax",
			"13": "Append format list has invalid %S, %s variable passed to. %S should be correspond to pointer to a buffer descriptor",
			"14": "Reallocating a HBufC16 / HBuf16 with new length is too small to hold current data",
			"16": "Length of the source descriptor is negative or exceeds the maximum length of the target descriptor to be replaced",
			"17": "Descriptor is constructed with negative length value",
			"18": "Descriptor is constructed with negative maximum length value",
			"19": "Pointer of 16-bit descriptor is invalid",
			"20": "Length passed to 8-bit variant descriptor is invalid",
			"21": "Accessing element of 8-bit descriptor out of range",
			"22": "Accessing element of 8-bit descriptor out of range",
			"23": "Destination 8-bit descriptor can't hold the data that is copied/moved from another descriptor (exceed maximum length)",
			"24": "8-bit format string has invalid syntax",
			"25": "Append format list has invalid %S, %s variable passed to. %S should be correspond to pointer to a buffer descriptor",
			"26": "Reallocating a HBufC8 / HBuf8 with new length is too small to hold current data",
			"28": "Length of the source descriptor is negative or exceeds the maximum length of the target descriptor to be replaced",
			"29": "Descriptor is constructed with negative length value",
			"30": "Descriptor is constructed with negative maximum length value",
			"32": "Trying to get mouse/touch position from TRawEvent when event is not touch/mouse move",
			"33": "Trying to get key code from TRawEvent when event is not key up/down",
			"34": "Trying to get modifiers from TRawEvent when event is not modifier update",
			"35": "At() of TKey is not overriden but called",
			"36": "Swap() of TSwap is not overriden but called",
			"37": "Accessing a negative index of TUidType. Index should be in 0 to 2",
			"38": "Length of the descriptor passed to TCheckedUid::Set(TDesC8&) is not equal to the size of a TCheckedUid object",
			"39": "Size of new heap is smaller than permitted minimum. Size must be at least equals to size of RHeap. This mostly be the cause of executable",
			"41": "Minimum length of heap is greater than the maximum size which heap can grow",
			"42": "Pointer (cell) passed to allocator memory adjustment function (Free, Realloc) is invalid, or doesn't exist",
			"43": "A heap is shrunked and the amount of cell shrunked is less then current total cell",
			"44": "The cell being freed overlaps the next cell on the free list",
			"45": "The cell being freed overlaps the previous cell on the free list",
			"46": "The cell being reallocated overlaps the next cell on the free list",
			"47": "Allocate a cell with size too big, larger than max of 4-bytes integer divide by 2",
			"48": "Heap walker find a bad allocated heap cell address",
			"49": "Heap walker find a bad freed heap cell address",
			"51": "DbgMarkEnd called when DbgMarkStart hasn't been called",
			"52": "Adjust a cell called with negative offset",
			"54": "Relloc a cell with new size negative",
			"55": "Minimum length of new heap is negative",
			"56": "Maximum length a heap can grow is negative"
		},
		
		"E32USER-CBase": {
			"1": "Async Callback already active",
			"2": "Async Oneshot not added",
			"3": "Dynamic buffer granularity value negative",
			"4": "Trying to read beyond EOB",
			"5": "Trying to write beyond EOB",
			"6": "Trying to read with size of negative",
			"7": "Trying to write with size of negative",
			"8": "Trying to insert/expand with size of negative",
			"9": "Trying to insert into a bad buffer (buffer pointer invalid)",
			"10": "Trying to reserve with size of negative",
			"11": "Trying to reserve a size for CBufFlat that is less then current size",
			"12": "Trying to delete, insert, expand, etc.. to a position out of range in CBufFlat",
			"13": "Trying to delete beyond end from a CBufFlat",
			"14": "Trying to access a CBufSeg out the range",
			"15": "Trying to delete a CBufSeg beyond end",
			"16": "Trying to remove/insert data greater than buffer granularity of CBufSeg",
			"17": "Array has invalid length (CArrayFixFlat or CArrayFixSeg)",
			"18": "Fixed array has invalid granularity passed to",
			"19": "Var array has invalid granularity passed to",
			"20": "Pak array has invalid granularity passed to",
			"21": "Trying to access array out of range",
			"22": "Deleting a part of fix array with count of negative",
			"23": "Inserting to fix array with count of negative",
			"24": "Resizing an fix array with count of negative",
			"25": "Deleting a part of var array with count of negative",
			"26": "Deleting a part of pak array with count of negative",
			"27": "Reserve an array with size less then the current size",
			"28": "Inserting replicated elements to fixed length array with count of negative",
			"29": "Deleting some elements from array with size too big",
			"30": "Inserting / deleting, etc.. to a array with element count of negative",
			"31": "Array reader count is virtual",
			"32": "Array reader at virtual",
			"33": "Delete a CObject when there is still open reference to it",
			"34": "Close a CObject when reference count is negative",
			"35": "CObject to remove is not found in the container supposed to contain it",
			"36": "CObject container not found to remove",
			"37": "Remove a bad CObject handle",
			"38": "The unique ID as derived from the handle is not the same as the unique ID held by the object container",
			"39": "Index of handle is out of range to the objects container",
			"40": "Deleting an active object while it still has a request outstanding",
			"41": "Active object already added to active scheduler",
			"42": "Active object already actived",
			"43": "Install an active scheduler when there is already one",
			"44" : "Active scheduler not installed",
			"45": "Stop the active scheduler more times than start",
			"46": "Active scheduler thread is signaled and it isn't ready yet.",
			"47": "An active object leaves",
			"48": "Adding a NULL active object",
			"49": "Active an active object that hasn't been added to active scheduler",
			"50": "Change priority of active object when it is still active",
			"51": "Timer active object hasn't been added to active scheduler but CTimer function has already been called.",
			"52": "Start timer with negative time interval passed",
			"53": "Start timer with negative delay passed",
			"54": "Unused",
			"55": "Unused",
			"56": "Bitmap allocator size construction is negative or equals to zero",
			"57": "Bitmap allocator offset to free is out of range",
			"58": "Bitmap allocator check if free offset is out of range",
			"59": "Bitmap allocator allocate from top offset is out of range",
			"60": "Bitmap allocator free too many time",
			"61": "Bitmap allocator free a memory that hasn't been allocated yet",
			"62": "Bitmap allocator allocate at offset that already been allocated",
			"63": "Popping cleanup stack items outside of current TRAP nest level",
			"64": "Pop more items that is on the clean up stack",
			"65": "Pop more items that is on the clean up stack",
			"66": "Push to cleanup stack when TRAP hasn't been called on the current level",
			"67": "Building TCleanupStack with NULL TCleanupOperation",
			"68": "No more slot on Cleanup Stack to insert items",
			"69": "No trap handler installed on the current thread",
			"70": "Pop items from cleanup stack with count of negative",
			"71": "Exit a TRAP level without popping all items of the current level from cleanup stack",
			"72": "Construct a circular buffer with size of zero or negative",
			"73": "Set length of a circular buffer with size of zero or negative",
			"74": "Add a null pointer to circular buffer",
			"75": "Number of items add to circular buffer is zero or negative",
			"76": "Number of items to remove from circular buffer is zero or negative",
			"77": "Getch console request is done but asynchronous result is not KErrNone",
			"78": "Not used",
			"79": "Bitmap allocator is in incosistent state",
			"80": "Bitmap allocator allocate from offset is out of range",
			"81": "Bitmap allocator allocate size is zero or negative",
			"82": "Bitmap allocator alloc align with aligment value greater than 32, zero or negative",
			"83": "Bitmap allocator alloc align block with aligment value greater than 32, zero or negative",
			"84": "Bitmap allocator allocate at is out of permitted range",
			"85": "Bitmap allocator is free offset is outside of permitted range",
			"86": "Bitmap allocator free is outside of permitted range",
			"87": "Bitmap allocator free a memory that hasn't been allocated",
			"88": "Attemp to allocate a block that isn't free from bitmap allocator",
			"89": "Replace an active scheduler that is the same with the current one",
			"90": "Item to be popped is not expected, this item may not be on the cleanup stack",
			"91": "CActiveSchedulerWait::Start is called but it has already been started",
			"92": "Stop a CActiveSchedulerWait when it hasn't been started",
			"93": "Fail to open a handle to CAsyncOneShot on the current thread",
			"94": "Bad security policy passed",
			"95": "CustomSecurityCheckL and CustomFailureActionL are not implemented in your policy server that derived from CPolicyServer",
			"96": "CPolicyServer constructor called with iRanges[0] has value not equal to zero",
			"97": "Each element of TPolicy::iRanges in CPolicyServer constructor is not greater than previous",
			"98": "Invalid TPolicy::iElementsIndex element",
			"99": "Invalid TPolicy::iOnConnect element",
			"100": "CPolicyServer::iPolicy is invalid",
			"101": "Policy server has invalid custom result",
			"102": "Policy server has invalid range count",
			"103": "Policy server panic client",
			"104": "CObjectIx is corrupted or inconsistent",
			"105": "A popped item modify the cleanup stack critical",
			"106": "A IPC arg pin is invalid"
		}
	}
}